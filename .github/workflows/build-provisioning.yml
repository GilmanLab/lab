name: Build Provisioning Artifacts

# on:
#   push:
#     #
#     #branches: [master]
#     # paths:
#     #   - '.github/workflows/build-provisioning.yml'
#     #   - 'provisioning/*/index.yaml'
#   workflow_dispatch:
#     inputs:
#       system:
#         description: 'System to build (talos, vyos, etc.)'
#         required: true
#         type: string
#       force:
#         description: 'Force rebuild even if artifacts exist'
#         type: boolean
#         default: false

# env:
#   IDRIVE_BUCKET: provisioning
#   IDRIVE_ENDPOINT: s3.us-west-1.idrivee2.com
#   IDRIVE_REGION: us-west-1

# jobs:
#   detect-changes:
#     runs-on: warp-ubuntu-latest-x64-4x
#     outputs:
#       systems: ${{ steps.changes.outputs.systems }}
#     steps:
#       - uses: actions/checkout@v4
#         with:
#           fetch-depth: 2

#       - id: changes
#         run: |
#           if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
#             echo "systems=[\"${{ inputs.system }}\"]" >> $GITHUB_OUTPUT
#           else
#             CHANGED=$(git diff --name-only HEAD~1 HEAD | grep 'provisioning/.*/index.yaml' | cut -d/ -f2 | sort -u | jq -R -s -c 'split("\n") | map(select(length > 0))')
#             if [ "$CHANGED" = "[]" ] || [ -z "$CHANGED" ]; then
#               echo "No provisioning changes detected"
#               echo "systems=[]" >> $GITHUB_OUTPUT
#             else
#               echo "Detected changes in: $CHANGED"
#               echo "systems=${CHANGED}" >> $GITHUB_OUTPUT
#             fi
#           fi

#   build:
#     needs: detect-changes
#     if: needs.detect-changes.outputs.systems != '[]'
#     runs-on: warp-ubuntu-latest-x64-4x
#     timeout-minutes: 60
#     strategy:
#       fail-fast: false
#       matrix:
#         system: ${{ fromJson(needs.detect-changes.outputs.systems) }}
#     steps:
#       - uses: actions/checkout@v4

#       - name: Install uv
#         uses: astral-sh/setup-uv@v4

#       - name: Install cosign
#         uses: sigstore/cosign-installer@v3

#       - name: Read manifest
#         id: manifest
#         run: |
#           MANIFEST="provisioning/${{ matrix.system }}/index.yaml"
#           echo "versions=$(yq -o=json -I=0 '.versions' $MANIFEST)" >> $GITHUB_OUTPUT

#       - name: Process versions
#         env:
#           IDRIVE_ACCESS_KEY: ${{ secrets.IDRIVE_ACCESS_KEY }}
#           IDRIVE_SECRET_KEY: ${{ secrets.IDRIVE_SECRET_KEY }}
#         run: |
#           SYSTEM="${{ matrix.system }}"
#           FORCE="${{ inputs.force || 'false' }}"

#           for VERSION in $(echo '${{ steps.manifest.outputs.versions }}' | jq -r '.[]'); do
#             echo ""
#             echo "=========================================="
#             echo "Processing ${SYSTEM} ${VERSION}"
#             echo "=========================================="

#             # Check if artifacts already exist (using AWS CLI which is pre-installed)
#             if [ "$FORCE" != "true" ]; then
#               export AWS_ACCESS_KEY_ID="${IDRIVE_ACCESS_KEY}"
#               export AWS_SECRET_ACCESS_KEY="${IDRIVE_SECRET_KEY}"
#               EXISTS=$(aws s3 ls "s3://${IDRIVE_BUCKET}/${SYSTEM}/${VERSION}/" \
#                 --endpoint-url "https://${IDRIVE_ENDPOINT}" \
#                 --region "${IDRIVE_REGION}" 2>/dev/null | wc -l || echo "0")
#               if [ "$EXISTS" -gt 0 ]; then
#                 echo "Artifacts exist for ${VERSION}, skipping (use force=true to rebuild)"
#                 continue
#               fi
#             fi

#             # Download ISO
#             echo "Downloading ${SYSTEM} ${VERSION}..."
#             ./scripts/download-iso.py "$SYSTEM" "$VERSION"

#             # Upload artifacts
#             echo "Uploading ${SYSTEM} ${VERSION}..."
#             ./scripts/upload-artifacts.py "$SYSTEM" "$VERSION"

#             echo "Completed ${SYSTEM} ${VERSION}"
#           done

on:
  push:

jobs:
  preflight:
    runs-on: warp-ubuntu-latest-x64-4x
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Preflight (collect + probe)
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p artifacts
          LOG="artifacts/preflight.log"
          exec > >(tee -a "$LOG") 2>&1

          section() { echo -e "\n\n===== $* =====\n"; }

          section "Runner + OS info"
          date -u
          whoami || true
          id || true
          uname -a || true
          cat /etc/os-release || true
          command -v lsb_release >/dev/null 2>&1 && lsb_release -a || true

          section "CPU virtualization flags + KVM devices"
          command -v lscpu >/dev/null 2>&1 && lscpu || true
          echo "vmx/svm flags sample:"
          grep -E '(^flags| vmx | svm )' /proc/cpuinfo | head -n 5 || true
          echo "/dev/kvm:"
          ls -lah /dev/kvm || true
          if [ -e /dev/kvm ]; then
            test -r /dev/kvm && echo "OK: /dev/kvm readable" || echo "WARN: /dev/kvm not readable"
            test -w /dev/kvm && echo "OK: /dev/kvm writable" || echo "WARN: /dev/kvm not writable"
          fi

          section "Loaded kernel modules"
          lsmod | grep -E '^kvm(_intel|_amd)?\b' || true
          if [ -e /sys/module/kvm_intel/parameters/nested ]; then
            echo "kvm_intel nested: $(cat /sys/module/kvm_intel/parameters/nested)"
          fi
          if [ -e /sys/module/kvm_amd/parameters/nested ]; then
            echo "kvm_amd nested: $(cat /sys/module/kvm_amd/parameters/nested)"
          fi

          section "Tooling inventory (preinstalled)"
          for c in \
            virsh virt-install virt-host-validate \
            qemu-system-x86_64 qemu-img qemu-img \
            iptables nft \
            curl jq yq \
            talosctl \
            sops \
            uv \
            ; do
            if command -v "$c" >/dev/null 2>&1; then
              echo "OK: $c -> $(command -v "$c")"
              "$c" --version 2>/dev/null | head -n 1 || true
            else
              echo "MISSING: $c"
            fi
          done

          section "Packages of interest (preinstalled)"
          if command -v dpkg >/dev/null 2>&1; then
            dpkg -l | awk 'NR==1 || $1=="ii"{print}' | grep -E '^(ii )?(qemu|libvirt|virtinst|ovmf|dnsmasq|iptables|nftables)\b' || true
          fi

          section "Attempt to start libvirt (if present)"
          if command -v systemctl >/dev/null 2>&1; then
            sudo -n true || echo "WARN: sudo without password may not be available"
            sudo -n systemctl status libvirtd --no-pager || true
            sudo -n systemctl start libvirtd || true
            sudo -n systemctl start virtlogd || true
            sudo -n systemctl status libvirtd --no-pager || true
          fi

          section "virsh connectivity (if available)"
          if command -v virsh >/dev/null 2>&1; then
            virsh -c qemu:///system uri || true
            virsh -c qemu:///system version || true
            virsh -c qemu:///system capabilities >/dev/null 2>&1 && echo "OK: virsh capabilities readable" || true
          fi

          section "KVM smoke test via qemu (if available)"
          if command -v qemu-system-x86_64 >/dev/null 2>&1; then
            set +e
            OUT="$(timeout 3s qemu-system-x86_64 -accel kvm -machine q35 -m 256 -nographic -S 2>&1)"
            RC=$?
            set -e
            echo "$OUT" | tail -n 50
            if echo "$OUT" | grep -qiE 'failed to initialize kvm|kvm is not supported|no accelerator found'; then
              echo "FAIL: qemu could not initialize KVM"
              exit 2
            fi
            # timeout(1) returns 124 when it kills the process; that's fine for this smoke.
            if [ "$RC" -ne 0 ] && [ "$RC" -ne 124 ]; then
              echo "WARN: qemu returned rc=$RC (non-timeout). See output above."
            else
              echo "OK: qemu started with -accel kvm (or at least did not error before timeout)"
            fi
          fi

          section "Optional: install libvirt/qemu/ovmf (for provisioning integration tests)"
          # This section is useful if you want this workflow to double as a self-healing CI preflight.
          # Comment it out if you only want to observe preinstalled state.
          if command -v apt-get >/dev/null 2>&1; then
            sudo -n apt-get update -y
            sudo -n apt-get install -y \
              libvirt-daemon-system \
              libvirt-clients \
              virtinst \
              qemu-system-x86 \
              qemu-utils \
              ovmf
          fi

          section "Post-install checks"
          if command -v systemctl >/dev/null 2>&1; then
            sudo -n systemctl start libvirtd || true
            sudo -n systemctl start virtlogd || true
            sudo -n systemctl status libvirtd --no-pager || true
          fi
          if command -v virsh >/dev/null 2>&1; then
            virsh -c qemu:///system uri || true
          fi

          section "Done"

      - name: Upload preflight logs
        uses: actions/upload-artifact@v4
        with:
          name: warpbuild-preflight-logs
          path: artifacts/

